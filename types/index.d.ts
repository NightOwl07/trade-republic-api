// Generated by dts-bundle-generator v9.5.1

export interface Message<T extends string> {
	type: T;
}
export type MessageTypeMap = {
	customerPermissions: Message<"customerPermissions">;
	compactPortfolioByType: Message<"compactPortfolioByType"> & {
		secAccNo?: string;
	};
	portfolioStatus: Message<"portfolioStatus">;
	orders: Message<"orders"> & {
		terminated: boolean;
	};
	cash: Message<"cash">;
	availableCash: Message<"availableCash">;
	availableCashForPayout: Message<"availableCashForPayout">;
	neonSearch: Message<"neonSearch"> & {
		data: {
			q: string;
			page: number;
			pageSize: number;
			filter: {
				key: string;
				value: string;
			}[];
		};
	};
	neonSearchSuggestedTags: Message<"neonSearchSuggestedTags"> & {
		data: {
			q: string;
		};
	};
	instrument: Message<"instrument"> & {
		id: string;
		jurisdiction: string;
	};
	homeInstrumentExchange: Message<"homeInstrumentExchange"> & {
		id: string;
	};
	savingsPlans: Message<"savingsPlans">;
	savingsPlanParameters: Message<"savingsPlanParameters"> & {
		instrumentId: string;
	};
	timelineSavingsPlanOverview: Message<"timelineSavingsPlanOverview"> & {
		savingsPlanId: string;
	};
	createSavingsPlan: Message<"createSavingsPlan"> & {
		parameters: {
			instrumentId: string;
			amount: number;
			startDate: {
				type: "dayOfMonth" | "twoPerMonth" | "monthly" | "quarterly";
				value: number;
				nextExecutionDate: string;
				availablePaymentMethods: string[];
			};
			interval: "weekly";
		};
		warningsShown: string[];
	};
	changeSavingsPlan: Message<"changeSavingsPlan"> & {
		id: string;
		parameters: {
			instrumentId: string;
			amount: number;
			startDate: {
				type: "dayOfMonth" | "twoPerMonth" | "monthly" | "quarterly";
				value: number;
				nextExecutionDate: string;
				availablePaymentMethods: string[];
			};
			interval: string;
		};
		warningsShown: string[];
	};
	cancelSavingsPlan: Message<"cancelSavingsPlan"> & {
		id: string;
	};
	ticker: Message<"ticker"> & {
		id: string;
	};
	namedWatchlist: Message<"namedWatchlist"> & {
		watchlistId: string;
	};
	frontendExperiment: Message<"frontendExperiment"> & {
		operation: "assignment" | "exposure";
		experimentId: string;
		identifier: string;
	};
	userPortfolioChartModifiedDietz: Message<"userPortfolioChartModifiedDietz"> & {
		range: "1d" | "5d" | "1m" | "1y" | "max";
	};
	fincrimeBanner: Message<"fincrimeBanner">;
	tradingPerkConditionStatus: Message<"tradingPerkConditionStatus">;
	watchlists: Message<"watchlists">;
	timelineActionsV2: Message<"timelineActionsV2">;
	timelineTransactions: Message<"timelineTransactions">;
	timelineActivityLog: Message<"timelineActivityLog">;
	timelineDetailV2: Message<"timelineDetailV2"> & {
		id: string;
	};
	collection: Message<"collection"> & {
		view: string;
	};
	availableSize: Message<"availableSize"> & {
		parameters: {
			exchangeId: string;
			instrumentId: string;
		};
	};
	aggregateHistoryLight: Message<"aggregateHistoryLight"> & {
		range: string;
		id: string;
		resolution?: string;
	};
	priceForOrder: Message<"priceForOrder"> & {
		parameters: {
			exchangeId: string;
			instrumentId: string;
			type: "buy" | "sell";
		};
	};
	stockDetails: Message<"stockDetails"> & {
		id: string;
		jurisdiction: string;
	};
	performance: Message<"performance"> & {
		id: string;
	};
	yieldToMaturity: Message<"yieldToMaturity"> & {
		id: string;
	};
	neonNews: Message<"neonNews"> & {
		isin: string;
	};
	instrumentSuitability: Message<"instrumentSuitability"> & {
		instrumentId: string;
	};
	simpleCreateOrder: Message<"simpleCreateOrder"> & {
		parameters: {
			instrumentId: string;
			exchangeId: string;
			mode: "market" | "limit" | "stopMarket";
			type: "buy" | "sell";
			size: number;
			expiry: {
				type: "gfd";
				value?: string;
			};
			acceptedTerms?: [
				{
					groupId: string;
					groupName: string;
				}
			];
			sellFractions: boolean;
			lastClientPrice: number;
		};
		warningsShown: string[];
		clientProcessId: string;
		secAccNo: string;
	};
	derivatives: Message<"derivatives"> & {
		jurisdiction: string;
		lang: string;
		underlying: string;
		productCategory: "knockOutProduct" | "vanillaWarrant" | "factorCertificate";
		leverage: number;
		sortBy: "leverage" | "factor" | "strike";
		sortDirection: string;
		optionType: "call" | "put" | "long" | "short";
		pageSize: number;
		after: string;
	};
	accountPairs: Message<"accountPairs">;
	neonSearchAggregations: Message<"neonSearchAggregations"> & {
		data: {
			q: string;
			filter: {
				key: string;
				value: string;
			}[];
		};
	};
	etfDetails: Message<"etfDetails"> & {
		id: string;
	};
	removeFromWatchlist: Message<"removeFromWatchlist"> & {
		instrumentId: string;
		watchlistId: "favorites";
	};
	addToWatchlist: Message<"addToWatchlist"> & {
		instrumentId: string;
		watchlistId: "favorites";
	};
	etfComposition: Message<"etfComposition"> & {
		id: string;
	};
	cancelOrder: Message<"cancelOrder"> & {
		id: string;
	};
	stockDetailDividends: Message<"stockDetailDividends"> & {
		id: string;
	};
	bondValuation: Message<"bondValuation"> & {
		instrumentId: string;
	};
	neonSearchTags: Message<"neonSearchTags">;
};
export declare function createMessage<T extends keyof MessageTypeMap>(type: T, data?: Omit<MessageTypeMap[T], "type">): MessageTypeMap[T];
export declare class TradeRepublicApi {
	private readonly phoneNo;
	private readonly pin;
	private static readonly HOST;
	private static readonly WS_HOST;
	private static readonly WS_CONNECT_VERSION;
	private ws?;
	private trSessionToken?;
	private trRefreshToken?;
	private rawCookies;
	private processId?;
	private subscriptions;
	private nextSubscriptionId;
	private echoIntervalId?;
	private readonly cookieFilePath;
	private reconnectAttempts;
	private pendingSubs;
	/**
	 * Initializes a new instance of the TradeRepublicApi
	 * @param phoneNo The phone number associated with the Trade Republic account
	 * @param pin The PIN for the Trade Republic account
	 * @param cookieStoragePath Optional path to store session cookies. Defaults to user's home directory
	 */
	constructor(phoneNo: string, pin: string, cookieStoragePath?: string);
	/**
	 * Logs into Trade Republic. It first attempts to use a saved session,
	 * then falls back to a full login flow if necessary
	 * @param getDevicePin callback that returns the device PIN sent to the phone
	 */
	login(getDevicePin?: () => Promise<string>): Promise<boolean>;
	/**
	 * Performs the initial step of the login process to get a processId
	 */
	private _performInitialLoginStep;
	/**
	 * Verifies the device PIN
	 * @param devicePin The PIN received on the user's device
	 */
	private _verifyDevicePin;
	/**
	 * Sets up the WebSocket connection
	 */
	private _setupWebSocket;
	/**
	 * Gracefully closes the WebSocket connection and clears related resources
	 */
	private _closeWebSocket;
	/**
	 * Makes an HTTP request to the Trade Republic API with timeout and optional cookies
	 */
	private _request;
	/**
	 * Asks a question to the user via the console
	 */
	private _askDevicePinFromStdin;
	/**
	 * Extracts a specific cookie value from the raw cookies
	 */
	private _extractCookieValue;
	/**
	 * Subscribe to a topic. Returns the subscription id
	 */
	subscribe<T extends keyof MessageTypeMap>(message: Message<T>, callback: (data: string | null) => void): number;
	/**
	 * Subscribe once to a topic. Returns the subscription id
	 */
	subscribeOnce<T extends keyof MessageTypeMap>(message: Message<T>, callback: (data: string | null) => void): number;
	/**
	 * Unsubscribe by id
	 */
	unsubscribe(id: number): void;
	private _subscribeInternal;
	private _flushPendingSubs;
	private _resubscribeAll;
	private _scheduleReconnect;
	private _startEcho;
	private _clearEchoInterval;
	private _sendEcho;
	private _handleWebSocketMessage;
	/**
	 * Parses a raw WebSocket message string into its ID and JSON payload
	 */
	private _parseWebSocketPayload;
	/**
	 * Saves the current session (tokens and cookies) to a file
	 */
	private _saveSessionToFile;
	/**
	 * Loads session data from the cookie file
	 */
	private _loadSessionFromFile;
	/**
	 * Attempts to load a saved session and validate it via WebSocket
	 */
	private loadAndValidateSavedSession;
	/**
	 * Performs a lightweight subscription to check if the current session token is valid
	 */
	private _performSessionValidationSubscription;
	/**
	 * Clears all local state (tokens, cookies, processId, WebSocket, timers)
	 * Does NOT clear the persisted cookie file
	 */
	private _clearLocalRuntimeState;
	/**
	 * Deletes the saved session file from disk
	 */
	private _deleteSavedSessionFile;
	/**
	 * Clears local runtime state and optionally the persisted session file
	 */
	private _clearSessionAndConnection;
	/**
	 * Logs out by clearing local state and the saved session file
	 */
	logout(): Promise<void>;
}
export interface Category {
	categoryType: string;
	positions: Position$1[];
}
interface Position$1 {
	instrumentType: string;
	name: string;
	derivativeInfo?: DerivativeInfo | null;
	bondInfo?: any | null;
	imageId: string;
	isin: string;
	averageBuyIn: string;
	netSize: string;
}
export interface DerivativeInfo {
	categoryType: string;
	productCategoryName: string;
	nextGenProductCategoryName: string;
	productGroupType: string;
	knocked: boolean;
	underlying: Underlying;
	properties: Properties;
	mifid: Mifid;
	issuerCountry: string;
	emissionDate: string;
}
export interface Underlying {
	name: string;
	isin: string;
	shortName: string;
	available: boolean;
}
export interface Properties {
	strike: number;
	barrier?: number | null;
	cap?: number | null;
	factor?: number | null;
	currency: string;
	size: number;
	expiry?: string | null;
	maturity?: string | null;
	exerciseType: string;
	settlementType: string;
	optionType: string;
	quoteType: string;
	firstTradingDay: string;
	lastTradingDay?: string | null;
	delta?: number | null;
	leverage: number;
	managementFee?: number | null;
}
export interface Mifid {
	entryCost: number;
	exitCost: number;
	ongoingCostsExpected: number;
	ongoingCostsAccumulated: number;
	costNotation: string;
}
export interface Portfolio {
	categories: Category[];
	products: any[];
}

export {
	Position$1 as Position,
};

export {};
