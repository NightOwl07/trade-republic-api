// @bun
import*as H from"readline";import*as X from"fs/promises";import*as Z from"path";import*as F from"os";function K(n,f){return{type:n,...f}}import{WebSocket as Q}from"ws";var m=".tr_api_cookies.json",q=1e4,C=7000,U=30000,g=1e4;class ${phoneNo;pin;static HOST="https://api.traderepublic.com";static WS_HOST="wss://api.traderepublic.com";static WS_CONNECT_VERSION="31";ws;trSessionToken;trRefreshToken;rawCookies=[];processId;subscriptions=[];nextSubscriptionId=1;echoIntervalId;cookieFilePath;reconnectAttempts=0;pendingSubs=[];constructor(n,f,y){this.phoneNo=n;this.pin=f;if(y)this.cookieFilePath=Z.resolve(y);else this.cookieFilePath=Z.join(F.homedir(),m)}async login(n=this._askDevicePinFromStdin){console.info("Attempting to log in...");try{if(await this.loadAndValidateSavedSession())return console.log("Successfully logged in using saved session. WebSocket setup completed."),!0;console.info("Saved session invalid or not found. Performing full login...");let f=await this._performInitialLoginStep();if(!f.processId)throw new Error("Login failed: no processId received from initial login step.");this.processId=f.processId;let y=await n();return await this._verifyDevicePin(y),await this._saveSessionToFile(),await this._setupWebSocket(),console.log("Login successful via full flow and WebSocket setup completed."),!0}catch(f){return console.error("Login failed:",f instanceof Error?f.message:f),await this._clearSessionAndConnection(!1),!1}}async _performInitialLoginStep(){let n=await this._request("/api/v1/auth/web/login",{phoneNumber:this.phoneNo,pin:this.pin});if(!n.ok){let f=await n.text();throw new Error(`Initial login request failed with status ${n.status}: ${f}`)}return await n.json()}async _verifyDevicePin(n){if(!this.processId)throw new Error("Cannot verify PIN without a processId. Login flow corrupted.");let f=await this._request(`/api/v1/auth/web/login/${this.processId}/${n}`);if(!f.ok){let x=await f.text();throw new Error(`Device PIN verification failed with status ${f.status}: ${x}`)}let G=f.headers.getSetCookie?.bind(f.headers);if(typeof G==="function")this.rawCookies=G();else{let x=f.headers.get("set-cookie");this.rawCookies=x?x.split(/,(?=\s*[A-Za-z0-9_\-]+=)/g):[]}if(this.trSessionToken=this._extractCookieValue("tr_session",!0),this.trRefreshToken=this._extractCookieValue("tr_refresh",!1),!this.trSessionToken)throw new Error("Critical: tr_session token not extracted after PIN verification.")}async _setupWebSocket(){if(this.ws&&this.ws.readyState===Q.OPEN){console.info("WebSocket already connected.");return}await this._closeWebSocket(),this._clearEchoInterval(),console.info(`Attempting to connect to WebSocket at ${$.WS_HOST}`),this.ws=new Q($.WS_HOST),await new Promise((n,f)=>{let y=setTimeout(()=>{this.ws?.removeAllListeners(),this.ws?.terminate(),this.ws=void 0,f(new Error(`WebSocket connection timed out after ${q/1000}s`))},q),G=()=>{clearTimeout(y),this.ws?.off("error",J),console.info("WebSocket connection opened.");let Y={locale:"en"};this.ws.send(`connect ${$.WS_CONNECT_VERSION} ${JSON.stringify(Y)}`),this._startEcho(),this.reconnectAttempts=0,this._flushPendingSubs(),this._resubscribeAll(),n()},x=(Y)=>{this._handleWebSocketMessage(Y.toString())},z=(Y,B)=>{console.info(`WebSocket connection closed. Code: ${Y}, Reason: ${B.toString()}`),this._clearEchoInterval(),this._scheduleReconnect()},J=(Y)=>{clearTimeout(y),this.ws?.off("open",G),this.ws?.off("message",x),console.error("WebSocket setup error:",Y.message),this.ws?.terminate(),this.ws=void 0,this._scheduleReconnect(),f(Y)};this.ws?.once("open",G),this.ws?.on("message",x),this.ws?.once("error",J),this.ws?.once("close",z)})}async _closeWebSocket(){if(this._clearEchoInterval(),this.ws){let n=this.ws.readyState;if(n===Q.OPEN||n===Q.CONNECTING){console.info("Closing WebSocket connection..."),this.ws.removeAllListeners();let f=new Promise((y)=>{this.ws.once("close",()=>{console.info("WebSocket connection confirmed closed."),y()}),this.ws.close()});await Promise.race([f,new Promise((y)=>{setTimeout(()=>{if(this.ws&&this.ws.readyState!==Q.CLOSED)console.warn("WebSocket close timed out, terminating."),this.ws.terminate();y()},2000)})])}else if(n===Q.CLOSING)await new Promise((f)=>this.ws.once("close",f));this.ws=void 0}}async _request(n,f=null,y="POST",G=!1){let x={"Content-Type":"application/json"};if(G&&this.rawCookies.length>0)x.Cookie=this.rawCookies.map((B)=>B.split(";")[0]).join("; ");let z={method:y,headers:x,body:y==="GET"||y==="DELETE"||!f?void 0:JSON.stringify(f)},J=new AbortController,Y=setTimeout(()=>J.abort(),g);try{return await fetch(`${$.HOST}${n}`,{...z,signal:J.signal})}finally{clearTimeout(Y)}}_askDevicePinFromStdin=async()=>{let n=H.createInterface({input:process.stdin,output:process.stdout});return new Promise((f)=>{n.question("Please enter the PIN received on your phone: ",(y)=>{n.close(),f(y)})})};_extractCookieValue(n,f=!0){let x=this.rawCookies.join("; ").match(new RegExp(`(?:^|;)\\s*${n}=([^;]+)`))?.[1];if(!x&&f)throw new Error(`Required cookie not found: ${n}`);return x}subscribe(n,f){return this._subscribeInternal(n,f,!1)}subscribeOnce(n,f){return this._subscribeInternal(n,f,!0)}unsubscribe(n){if(this.subscriptions=this.subscriptions.filter((f)=>f.id!==n),this.ws&&this.ws.readyState===Q.OPEN)try{this.ws.send(`unsub ${n}`)}catch(f){console.warn("Failed to send unsub:",f.message)}}_subscribeInternal(n,f,y){if(!this.trSessionToken)return console.error("Session token is not available. Cannot subscribe."),-1;let G=this.nextSubscriptionId++,x=()=>{if(!this.ws||this.ws.readyState!==Q.OPEN){console.error("WebSocket connection not established or not open. Cannot subscribe now.");return}try{this.ws.send(`sub ${G} ${JSON.stringify({token:this.trSessionToken,...n})}`)}catch(z){console.error("Failed to send subscription:",z instanceof Error?z.message:z)}};if(this.subscriptions.push({id:G,topic:n.type,payload:n,callback:f,isOneTime:y}),this.ws?.readyState===Q.OPEN)x();else this.pendingSubs.push(x);return G}_flushPendingSubs(){if(!this.pendingSubs.length)return;let n=this.pendingSubs.splice(0);for(let f of n)try{f()}catch(y){console.warn("Error flushing pending subscription:",y.message)}}_resubscribeAll(){if(!this.ws||this.ws.readyState!==Q.OPEN)return;for(let n of this.subscriptions)try{this.ws.send(`sub ${n.id} ${JSON.stringify({token:this.trSessionToken,...n.payload})}`)}catch(f){console.warn(`Failed to resubscribe ${n.id}:${n.topic}`,f.message)}}_scheduleReconnect(){let n=Math.min(30000,1000*2**this.reconnectAttempts++);setTimeout(async()=>{try{await this._setupWebSocket()}catch{}},n)}_startEcho(){if(this.echoIntervalId)clearInterval(this.echoIntervalId);this.echoIntervalId=setInterval(()=>this._sendEcho(),U)}_clearEchoInterval(){if(this.echoIntervalId)clearInterval(this.echoIntervalId),this.echoIntervalId=void 0}_sendEcho(){if(!this.ws||this.ws.readyState!==Q.OPEN){console.warn("Cannot send echo, WebSocket not open.");return}try{let n=`echo ${Date.now()}`;this.ws.send(n)}catch(n){console.error("Failed to send echo:",n instanceof Error?n.message:n)}}_handleWebSocketMessage(n){if(n.startsWith("echo"))return;if(n.startsWith("connected")){console.info("WebSocket acknowledged connection:",n);return}let f=this._parseWebSocketPayload(n);if(!f)return;let{subscriptionId:y,jsonData:G}=f;if(y===null){if(n.includes("failed")||n.includes("error"))console.warn("Received unhandled or general error message from WebSocket:",n);return}let x=this.subscriptions.findIndex((z)=>z.id===y);if(x!==-1){let z=this.subscriptions[x];try{z.callback(G)}catch(J){console.error(`Error in subscription callback for ID ${y}, topic ${z.topic}:`,J instanceof Error?J.message:J)}if(z.isOneTime)this.subscriptions.splice(x,1)}}_parseWebSocketPayload(n){let f=n.indexOf("{");if(f!==-1){let G=n.substring(0,f).trim().match(/\d+/),x=G?Number(G[0]):null,z=n.substring(f).trim();return{subscriptionId:x,jsonData:z}}else return{subscriptionId:null,jsonData:null}}async _saveSessionToFile(){if(this.trSessionToken&&this.rawCookies.length>0){let n={trSessionToken:this.trSessionToken,trRefreshToken:this.trRefreshToken,rawCookies:this.rawCookies};try{await X.mkdir(Z.dirname(this.cookieFilePath),{recursive:!0}),await X.writeFile(this.cookieFilePath,JSON.stringify(n,null,2),{encoding:"utf-8",mode:384}),console.info("Session data saved to:",this.cookieFilePath)}catch(f){console.error("Error saving session data to file:",this.cookieFilePath,f)}}else console.warn("No session token or raw cookies to save. Skipping save.")}async _loadSessionFromFile(){try{await X.access(this.cookieFilePath)}catch(n){if(n.code==="ENOENT")console.info("Session file not found. A new session will be created if login proceeds.");else console.warn("Error accessing session file (permissions?):",this.cookieFilePath,n.message);return null}try{let n=await X.readFile(this.cookieFilePath,"utf-8");if(!n.trim())return console.warn("Session file is empty. Will be overwritten on next successful login."),await this._deleteSavedSessionFile(),null;let f=JSON.parse(n);if(f.trSessionToken&&Array.isArray(f.rawCookies))return console.info("Session data loaded from:",this.cookieFilePath),f;return console.warn("Loaded session file is malformed (missing token or rawCookies). It will be overwritten."),await this._deleteSavedSessionFile(),null}catch(n){return console.warn("Error loading/parsing session data from file:",this.cookieFilePath,n.message),await this._deleteSavedSessionFile(),null}}async loadAndValidateSavedSession(){let n=await this._loadSessionFromFile();if(!n?.trSessionToken)return!1;this.trSessionToken=n.trSessionToken,this.trRefreshToken=n.trRefreshToken,this.rawCookies=n.rawCookies,console.info("Loaded session from file. Validating session via WebSocket...");try{if(await this._setupWebSocket(),!this.ws||this.ws.readyState!==Q.OPEN)return console.warn("WebSocket not open after setup attempt during saved session validation."),await this._clearSessionAndConnection(!0),!1;if(await this._performSessionValidationSubscription())return console.info("Saved session is valid and WebSocket is ready."),!0;else return console.warn("Saved session validation failed (token likely expired or invalid)."),await this._clearSessionAndConnection(!0),!1}catch(f){return console.warn("Error during saved session validation or WebSocket setup:",f.message||f),await this._clearSessionAndConnection(!0),!1}}_performSessionValidationSubscription(){let n=K("availableCash");return new Promise((f)=>{let y=null,G=!1,x=(z)=>{if(G)return;if(G=!0,y)clearTimeout(y),y=null;f(z)};try{this.subscribeOnce(n,(z)=>{if(z===null){console.warn("Session validation subscription received null data string. Assuming invalid."),x(!1);return}try{if(z.includes("AUTHENTICATION_ERROR"))console.warn("Session validation subscription indicated an error:",z),x(!1);else console.info("Session validation subscription successful."),x(!0)}catch(J){console.warn("Error parsing payload during session validation:",J instanceof Error?J.message:J,"Raw data:",z),x(!1)}})}catch(z){console.error("Error initiating session validation subscription:",z instanceof Error?z.message:z),x(!1)}y=setTimeout(()=>{if(!G)console.warn(`Session validation subscription timed out after ${C/1000}s.`),x(!1)},C)})}async _clearLocalRuntimeState(){console.debug("Clearing local runtime state..."),this.trSessionToken=void 0,this.trRefreshToken=void 0,this.rawCookies=[],this.processId=void 0,this.subscriptions=[],this.nextSubscriptionId=1,this.pendingSubs=[],await this._closeWebSocket()}async _deleteSavedSessionFile(){try{await X.access(this.cookieFilePath),await X.unlink(this.cookieFilePath),console.info("Saved session file deleted:",this.cookieFilePath)}catch(n){if(n.code==="ENOENT");else console.error("Error deleting saved session file:",this.cookieFilePath,n.message)}}async _clearSessionAndConnection(n){if(await this._clearLocalRuntimeState(),n)await this._deleteSavedSessionFile()}async logout(){console.info("Logging out and clearing session..."),await this._clearSessionAndConnection(!0),console.info("Local session cleared, saved session file deleted, and WebSocket closed.")}}export{K as createMessage,$ as TradeRepublicApi};
